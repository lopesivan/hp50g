%%HP: T(0)A(D)F(.);

 X PEVAL EXPAND

func
STO

  P, X0, degree
 
   {} 'cofs' STO
   P func
   X0
   1 degree
   FOR I  @ "I" is the local variable
     HORNER
     cofs
     +
     'cofs' STO
   NEXT    @ Repeat...
   {1} cofs +
   {cofs} PURGE
 

briot
STO

 DUP2
  P, X0
 
   1 P AXL SIZE 1 -
   FOR I
     P
     X0
     I
     briot
     ROT
     func AXL
     1 I
     START
       0
     NEXT
     I LIST
     +
     SWAP DROP
     SWAP DROP
   NEXT
   P AXL SIZE 1 - jLrmatrix
   @'DAT' STO
   STO
   "Briot-Ruffini"
   DAT
 

briot
STO

 HOME main
 -3.  usetf
 -22. setf
 -27. setf
 -34. setf
 -55. setf
 -56. setf
 -68. setf
 -72. setf
 -73. setf
 -74. setf
 -74. usetf
 -80. setf
 -81. setf
 -82. setf
 -90. setf
 -95. usetf
 -97. setf
 -98. setf
 -105. usetf
 -111. setf
 -116. setf
 -117. setf
 -119. setf
 -120. setf
 -128. setf

conf
STO

 44.2 KEYEVAL
 11.1 KEYEVAL
 33 KEYEVAL

coord
STO

 X \.d

derivadafx
STO

 0 SWAP
 WHILE DUP FXND NIP 1 >
 REPEAT DUP INV FXND IDIV2 DUP
    IF 0 \=!
    THEN SIGN
    END
    + INV ROT OVER + UNROT - EVAL
 END DROP

egyptfrac
STO

 { } SWAP
 DO
   RCLVX DIV2 ROT + SWAP
 UNTIL { 0 0. } OVER POS
 END
 DROP
 AXL

func
STO

   DUP 1 + 2 LIST ARRY 'DAT' STO DAT RREF

inMatrref
STO

 2 LIST ARRY B STO
 2 LIST ARRY A STO
 A INV B *
 {A B} PURGE

inMatSol
STO

 0 X 3 ROLL X \.S

integralfx
STO
 "usage: {Xi Xf}, f, {X Y Z}"  u
 
    ab, f, dx
   
     IF dx SIZE 2 * ab SIZE =
     THEN u DOERR
     END
     ab AXL 2 ab SIZE 2 / rdmmatrix
     f
     1 dx SIZE 1 -
     FOR I
       SWAP
       dx SIZE I - 1 + COL- AXL OBJ DROP SWAP
       4 ROLL
       dx
       I GET
       \.S
     NEXT
     SWAP
     OBJ DROP SWAP
     ROT
     dx
     dx SIZE GET
     \.S
   
 

nInt
STO

 1 4
 START
   7 ROLL
 NEXT
 4 LIST
 UNROT
 2 LIST
 ROT SWAP
 nInt

IInt
STO

 1 6
 START
   10 ROLL
 NEXT
 6 LIST
 5 ROLLD
 3 LIST
 nInt

IIInt
STO

 22.2 KEYEVAL

LoadCST
STO

   2 LIST ARRY

matrix
STO

   OBJ OBJ DROP

matrix
STO

   2 LIST RDM

rdmmatrix
STO

   2 LIST DIAG

diagmatrix
STO

   LIST VANDERMONDE

vander
STO

   2 LIST RANM

rndmatrix
STO

 2 LIST UNROT
 2 LIST
 SWAP
 SUB

submatrix
STO

 2 LIST SWAP REPL

replacematrix
STO

   2 LIST GET

get
STO

   UNROT 2 LIST SWAP CON

conmatrix
STO

   UNROT 2 LIST SWAP PUT

put
STO

   2 LIST GETI

geti
STO

   UNROT 2 LIST SWAP PUTI

puti
STO
 DUP
  n
 
   1 SWAP
   FOR J
     OBJ
     ARRY
     IF J n <
     THEN
       J 1 + ROLL
     END
   NEXT
   IF n 1 >
   THEN
     1 n 1 -
     FOR J
       J 1 + ROLL
     NEXT
   END
   n COL
 

jLcmatrix
STO
 DUP
  n
 
   1 SWAP
   FOR J
     OBJ
     ARRY
     IF J n <
     THEN
       J 1 + ROLL
     END
   NEXT
   IF n 1 >
   THEN
     1 n 1 -
     FOR J
       J 1 + ROLL
     NEXT
   END
   n ROW
 

jLrmatrix
STO
  a b
 
   'a*COS(b)+a*SIN(b)*i' EVAL
 

SC
STO
  x
 
   IF x FC?C
   THEN x SF
   END
 

setf
STO
  message
 
   PUSH -70 SF
   "\127\127\127\127\127Show Formula\127\127\127\127\127"
   __TITLE__:Show Formula
   0 GROB
   message
   0 GROB GROBADD
   ""
   0 GROB GROBADD
   EQ
   0 GROB GROBADD
   SCROLL
   POP
 
 EQ

showformula
STO

 -105 setf
 -3 setf
 -17 usetf

toFloat
STO

 -105 usetf
 -3 usetf
 -17 setf

toInteger
STO
 -18 CF -17 FS?  X
 
   IF 'X'
   THEN DEG
   ELSE RAD
   END
 

DR
STO

 IF -103. FS?
 THEN -103. usetf
 ELSE -103. setf
 END

RC
STO
 -15 CF -16 FS?  X
 
   IF 'X'
   THEN RECT
   ELSE CYLIN
   END
 

XYP
STO
  x
   
     IF x FC?
     THEN 0.
     ELSE x CF
     END
   

usetf
STO

 AXL SWAP AXL SWAP / AXL

vectorDivide
STO

 AXL SWAP AXL SWAP ^ AXL

vectorExp
STO

 HADAMARD

vectorMultiply
STO

 AXL LIST EVAL

vector
STO

 SWAP TRAN * TRACE EVAL

vector.
STO
  str, N
    1 N
     FOR I
       str I + OBJ
     NEXT
   

Xn
STO
